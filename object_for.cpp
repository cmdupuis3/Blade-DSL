/***********************************************************************
 *                   GNU Lesser General Public License
 *
 * This file is part of the EDGI package, developed by the
 * GFDL Flexible Modeling System (FMS) group.
 *
 * EDGI is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at
 * your option) any later version.
 *
 * EDGI is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with EDGI.  If not, see <http://www.gnu.org/licenses/>.
 **********************************************************************/

#ifndef OBJECT_FOR_CPP
#define OBJECT_FOR_CPP

#include <functional>
#include <type_traits>

#include "nested_array.cpp"

using std::add_pointer;
using std::remove_pointer;

//-----------------------------------------------------------------------//
//
// To any who dare tread here: I recommend running away, flailing wildly,
// and/or hysterical screaming. If you are not afraid, you should be.
//
//-----------------------------------------------------------------------//


/** The object_for loop is a grammatical orientation of the nested_for loop that allows you to tie an
 *  iteration pattern to a function, and later pass it input and output arrays for the function to evaluate.
 *  This is useful for evaluating a function as applied to multiple different input arrays of arbitrary
 *  shape and dimensionality.
 *
 *  Nested_for loops create the iteration pattern for a given input and output array by indexing down into
 *  both input and output arrays until the output array rank matches the function output array rank. From
 *  there, they continue indexing down into the input array, passing along the final output array. When the
 *  input array rank matches the function input array rank, we call the function. Nested_for loops can be
 *  understood as a kind of branchy combinator that nests for loops inside each other.
 *
 *  Each class specialization is generated by recursively instantiating object_for_impl lambdas as it
 *  decrements the array rank(s) it's working with. Beware: if the function type never matches the combo
 *  of dereferenced array types, you will get an infinite loop at compile time! However, *all* needed class
 *  specializations must be available at runtime, so all logic in choosing the correct loop, including all
 *  subsequent specializations required due to the type cascade, must be completed at compile time.
 *
 *  Only the top-level object is created upon loop declaration by the user. Calling the function operator
 *  (i.e., '()' ) kicks off a cascade of object creations, where all the other loops are actually generated.
 *  Thus, the compile-time logic only chooses the correct loop type; the runtime is responsible for deciding
 *  the iteration bounds for each loop, and actually launching it.
 *
 *  Nested_for loops support symmetry optimization. The best way to structure data for symmetry
 *  optimization is to ensure that all symmetric dimensions in a symmetry group are sequential. Mixed
 *  grouping will break this optimization. A 1-D array of arbitrary integers; equal values
 *  imply symmetry between different dimensions.
 *
 * @tparam ITYPE    The input array's value type.
 * @tparam IRANK    The rank (or dimensionality) of the input array.
 * @tparam ISYM     The input array's symmetry vector.
 * @tparam FIRANK   The rank (or dimensionality) of array that will be passed to the function as input.
 * @tparam OTYPE    The output array's value type.
 * @tparam ORANK    The rank (or dimensionality) of the output array.
 * @tparam FORANK   The rank (or dimensionality) of array that will be passed to the function as output.
 * @tparam OMP_LEVELS   The number of dimensions to parallelize with OpenMP. This will apply to the first
 *                      OMP_LEVELS dimensions.
 * @tparam DEPTH    How deep we currently are in the input array. Only needed to assist with symmetry
 *                  optimization; this is only for use within this class and should not be set in external
 *                  implementations.
 *
 * @return          A lambda function that iterates through the input array's top-level dimension,
 *                  and spawns new method_for_base_t objects to continue traversal when called. At the lowest
 *                  level, it stores a lambda function that simply calls the function on the data. method_for
 *                  loops have a recursive function type that nests with input array rank.
 */
template<typename ITYPE, const int IRANK, const int* ISYM, const int FIRANK,
         typename OTYPE, const int ORANK,                  const int FORANK,
         const int OMP_LEVELS = 0, const int DEPTH = 0>
constexpr auto object_for_impl(std::function<void(nested_array_t<ITYPE, FIRANK, ISYM>, nested_array_t<OTYPE, FORANK>)> func_in, const int imin_in = 0){

    // Are we done appending loops?
    if constexpr (IRANK == FIRANK) {

        return [func_in](nested_array_t<ITYPE, IRANK, ISYM> iarray, nested_array_t<OTYPE, ORANK> oarray) {
            func_in(iarray, oarray);
        };

    } else if constexpr (IRANK > FIRANK) {

        return [func_in, imin_in](nested_array_t<ITYPE, IRANK, ISYM> iarray, nested_array_t<OTYPE, ORANK> oarray) {

            if constexpr (DEPTH == 0) {
                for (int i = 0; i < IRANK - FIRANK; i++) {
                    oarray.set_extent(i, iarray.extent(i));
                }
            }

            auto loop = [func_in, iarray, oarray](int i){
                // Is this dimension symmetric with the next one?
                if constexpr (ISYM && DEPTH < IRANK - FIRANK && ISYM[DEPTH] == ISYM[DEPTH + 1]){
                    // Are we done stripping off output dimensions?
                    if constexpr (ORANK == FORANK) {
                        object_for_impl<ITYPE, IRANK - 1, ISYM, FIRANK, OTYPE, ORANK,     FORANK, OMP_LEVELS - 1, DEPTH + 1>(func_in, i)(iarray(i), oarray);
                    } else {
                        object_for_impl<ITYPE, IRANK - 1, ISYM, FIRANK, OTYPE, ORANK - 1, FORANK, OMP_LEVELS - 1, DEPTH + 1>(func_in, i)(iarray(i), oarray(i));
                    }
                } else {
                    if constexpr (ORANK == FORANK) {
                        object_for_impl<ITYPE, IRANK - 1, ISYM, FIRANK, OTYPE, ORANK,     FORANK, OMP_LEVELS - 1, DEPTH + 1>(func_in)(iarray(i), oarray);
                    } else {
                        object_for_impl<ITYPE, IRANK - 1, ISYM, FIRANK, OTYPE, ORANK - 1, FORANK, OMP_LEVELS - 1, DEPTH + 1>(func_in)(iarray(i), oarray(i));
                    }
                }
            };

            if constexpr (OMP_LEVELS > 0) {
                int i = imin_in;
                #pragma omp parallel for private(i)
                for (i = imin_in; i < iarray.current_extent(); i++) {
                    loop(i);
                }
            } else { // if constexpr (OMP_LEVELS == 0)
                for (int i = imin_in; i < iarray.current_extent(); i++) {
                    loop(i);
                }
            }

        };

    }

}

/** The object_for loop is a grammatical orientation of the nested_for loop that allows you to tie an
 *  iteration pattern to a function, and later pass it input and output arrays for the function to evaluate.
 *  This is useful for evaluating a function as applied to multiple different input arrays of arbitrary
 *  shape and dimensionality.
 *
 *  object_for loops also support symmetry optimization. The best way to structure data for symmetry
 *  optimization is all symmetric dimensions in a symmetry group are sequential. Mixed grouping will
 *  break this optimization.
 *
 * @tparam NITYPE       The input array type.
 * @tparam NOTYPE       The output array type.
 * @tparam CLTYPE       The closure type.
 * @tparam OMP_LEVELS   The number of dimensions to parallelize with OpenMP. This will apply to the first
 *                      OMP_LEVELS dimensions.
 *
 * @return          A lambda function that iterates through the input array's top-level dimension,
 *                  and spawns new method_for_base_t objects to continue traversal when called. At the lowest
 *                  level, it stores a lambda function that simply calls the function on the data. method_for
 *                  loops have a recursive function type that nests with input array rank.
 */
template<typename NITYPE, typename NOTYPE, typename CLTYPE, const int OMP_LEVELS = 0>
constexpr auto object_for(std::function<void(nested_array_t<typename CLTYPE::fitype, CLTYPE::input_rank,  NITYPE::symmetry>,
                                             nested_array_t<typename CLTYPE::fotype, CLTYPE::output_rank>)> func_in){
    return object_for_impl<typename NITYPE::value_type, NITYPE::rank, NITYPE::symmetry, CLTYPE::input_rank,
                           typename NOTYPE::value_type, NOTYPE::rank,                   CLTYPE::output_rank,
                           OMP_LEVELS>(func_in);
}

#endif

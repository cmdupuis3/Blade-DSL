/***********************************************************************
 *                   GNU Lesser General Public License
 *
 * This file is part of the EDGI package, developed by the 
 * GFDL Flexible Modeling System (FMS) group.
 *
 * EDGI is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at
 * your option) any later version.
 *
 * EDGI is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with EDGI.  If not, see <http://www.gnu.org/licenses/>.
 **********************************************************************/

#ifndef OBJECT_FOR_CPP
#define OBJECT_FOR_CPP

#include <functional>
#include <type_traits>

#include "nested_array.cpp"
#include "curry.cpp"

using std::add_pointer;
using std::remove_pointer;

//-----------------------------------------------------------------------//
//
// To any who dare tread here: I recommend running away, flailing wildly,
// and/or hysterical screaming. If you are not afraid, you should be.
//
//-----------------------------------------------------------------------//

/** The object_for loop is a grammatical orientation of the nested_for loop that allows you to tie an
 *  iteration pattern to a function, and later pass it input and output arrays for the function to evaluate.
 *  This is useful for evaluating a function as applied to multiple different input arrays of arbitrary
 *  shape and dimensionality.
 *
 *  Nested_for loops create the iteration pattern for a given input and output array by indexing down into
 *  both input and output arrays until the output array rank matches the function output array rank. From
 *  there, they continue indexing down into the input array, passing along the final output array. When the
 *  input array rank matches the function input array rank, we call the function. Nested_for loops can be
 *  understood as a kind of branchy combinator that nests for loops inside each other.
 *
 *  Each class specialization is generated by recursively instantiating method_for_base_t functors as it
 *  decrements the array rank(s) it's working with. Beware: if the function type never matches the combo
 *  of dereferenced array types, you will get an infinite loop at compile time! However, *all* needed class
 *  specializations must be available at runtime, so all logic in choosing the correct loop, including all
 *  subsequent specializations required due to the type cascade, must be completed at compile time.
 *
 *  Only the top-level object is created upon loop declaration by the user. Calling the function operator
 *  (i.e., '()' ) kicks off a cascade of object creations, where all the other loops are actually generated.
 *  Thus, the compile-time logic only chooses the correct loop type; the runtime is responsible for deciding
 *  the iteration bounds for each loop, and actually launching it.
 *
 *  Nested_for loops support symmetry optimization. The best way to structure data for symmetry
 *  optimization is to ensure that all symmetric dimensions in a symmetry group are sequential. Mixed
 *  grouping will break this optimization. A 1-D array of arbitrary integers; equal values
 *  imply symmetry between different dimensions.
 *
 * @tparam ARITY    The number of arguments the function will accept. In other words, the function will
 *                  require this many elements from the input array to be calculated.
 * @tparam ITYPE    The input array's value type.
 * @tparam IRANK    The rank (or dimensionality) of the input array.
 * @tparam ISYM     The input array's symmetry vector.
 * @tparam FIRANK   The rank (or dimensionality) of array that will be passed to the function as input.
 * @tparam ICOM     The function's commutativity vector.
 * @tparam OTYPE    The output array's value type.
 * @tparam ORANK    The rank (or dimensionality) of the output array.
 * @tparam OSYM     The output array's symmetry vector.
 * @tparam FORANK   The rank (or dimensionality) of array that will be passed to the function as output.
 * @tparam FOTYPE   The function ouput type.
 * @tparam OMP_LEVELS   The number of dimensions to parallelize with OpenMP. This will apply to the first
 *                      OMP_LEVELS dimensions.
 * @tparam DEPTH    How deep we currently are in the input array. Only needed to assist with symmetry
 *                  optimization; this is only for use within this class and should not be set in
 *                  implementations.
 *
 * @typedef FTYPE   The function type.
 *
 * @param loop      Stores a lambda function that iterates through the input array's top-level dimension,
 *                  and spawns new method_for_base_t objects to continue traversal when called. At the lowest
 *                  level, it stores a lambda function that simply calls the function on the data. method_for
 *                  loops have a recursive function type that nests with input array rank.
 */
template<const int ARITY, typename ITYPE, const int IRANK, const int* ISYM, const int FIRANK, const int* ICOM,
                          typename OTYPE, const int ORANK, const int* OSYM, const int FORANK, const int OMP_LEVELS = 0,
                          const int DEPTH = 0>
class object_for_base_t {

    typedef const void (FTYPE)(nested_array_t<ITYPE, FIRANK, ISYM>, nested_array_t<OTYPE, FORANK, OSYM>);

    std::function<void(nested_array_t<ITYPE, IRANK, ISYM>, nested_array_t<OTYPE, ORANK, OSYM>)> loop;

public:
    object_for_base_t(FTYPE func_in, const int imin_in = 0);
    ~object_for_base_t(){};

    std::function<void(nested_array_t<ITYPE, IRANK, ISYM>, nested_array_t<OTYPE, ORANK, OSYM>)> operator()();
    void operator()(nested_array_t<ITYPE, IRANK, ISYM> iarray_in, nested_array_t<OTYPE, ORANK, OSYM> oarray_in);

};

template<const int ARITY, typename ITYPE, const int IRANK, const int* ISYM, const int FIRANK, const int* ICOM,
                          typename OTYPE, const int ORANK, const int* OSYM, const int FORANK, const int OMP_LEVELS,
                          const int DEPTH>
object_for_base_t<ARITY, ITYPE, IRANK, ISYM, FIRANK, ICOM, OTYPE, ORANK, OSYM, FORANK, OMP_LEVELS, DEPTH>::object_for_base_t(FTYPE func_in, const int imin_in){

    // Are we done appending loops?
    if constexpr (IRANK == FIRANK) {

        this->loop = [func_in](nested_array_t<ITYPE, IRANK, ISYM> iarray, nested_array_t<OTYPE, ORANK, OSYM> oarray){
            func_in(iarray, oarray);
        };

    } else {

        // Are we done stripping off output dimensions?
        if constexpr (ORANK == FORANK) {

            // Is this dimension symmetric with the next one?
            if constexpr (ISYM && DEPTH < IRANK - FIRANK && ISYM[DEPTH] == ISYM[DEPTH + 1]) {
                if constexpr (OMP_LEVELS != 0) {
                    this->loop = [func_in, imin_in](nested_array_t<ITYPE, IRANK, ISYM> iarray, nested_array_t<OTYPE, ORANK, OSYM> oarray){
                        #pragma omp parallel for
                        for(int i = imin_in; i < iarray.current_extent(); i++){
                            object_for_base_t< ARITY, ITYPE, IRANK - 1, ISYM, FIRANK, ICOM, OTYPE, ORANK, OSYM, FORANK, OMP_LEVELS - 1, DEPTH + 1
                                > next(func_in, i);
                            next(iarray(i), oarray);
                        }
                    };
                } else {
                    this->loop = [func_in, imin_in](nested_array_t<ITYPE, IRANK, ISYM> iarray, nested_array_t<OTYPE, ORANK, OSYM> oarray){
                        for(int i = imin_in; i < iarray.current_extent(); i++){
                            object_for_base_t< ARITY, ITYPE, IRANK - 1, ISYM, FIRANK, ICOM, OTYPE, ORANK, OSYM, FORANK, OMP_LEVELS, DEPTH + 1
                                > next(func_in, i);
                            next(iarray(i), oarray);
                        }
                    };
                }
            } else {
                if constexpr (OMP_LEVELS != 0) {
                    this->loop = [func_in, imin_in](nested_array_t<ITYPE, IRANK, ISYM> iarray, nested_array_t<OTYPE, ORANK, OSYM> oarray){
                        #pragma omp parallel for
                        for(int i = imin_in; i < iarray.current_extent(); i++){
                            object_for_base_t< ARITY, ITYPE, IRANK - 1, ISYM, FIRANK, ICOM, OTYPE, ORANK, OSYM, FORANK, OMP_LEVELS - 1, DEPTH + 1
                                > next(func_in);
                            next(iarray(i), oarray);
                        }
                    };
                } else {
                    this->loop = [func_in, imin_in](nested_array_t<ITYPE, IRANK, ISYM> iarray, nested_array_t<OTYPE, ORANK, OSYM> oarray){
                        for(int i = imin_in; i < iarray.current_extent(); i++){
                            object_for_base_t< ARITY, ITYPE, IRANK - 1, ISYM, FIRANK, ICOM, OTYPE, ORANK, OSYM, FORANK, OMP_LEVELS, DEPTH + 1
                                > next(func_in);
                            next(iarray(i), oarray);
                        }
                    };
                }
            }

        } else {

            // Is this dimension symmetric with the next one?
            if constexpr (ISYM && DEPTH < IRANK - FIRANK && ISYM[DEPTH] == ISYM[DEPTH + 1]) {
                if constexpr (OMP_LEVELS != 0) {
                    this->loop = [func_in, imin_in](nested_array_t<ITYPE, IRANK, ISYM> iarray, nested_array_t<OTYPE, ORANK, OSYM> oarray){
                        #pragma omp parallel for
                        for(int i = imin_in; i < iarray.current_extent(); i++){
                            object_for_base_t< ARITY, ITYPE, IRANK - 1, ISYM, FIRANK, ICOM, OTYPE, ORANK - 1, OSYM, FORANK, OMP_LEVELS - 1, DEPTH + 1
                                > next(func_in, i);
                            next(iarray(i), oarray(i));
                        }
                    };
                } else {
                    this->loop = [func_in, imin_in](nested_array_t<ITYPE, IRANK, ISYM> iarray, nested_array_t<OTYPE, ORANK, OSYM> oarray){
                        for(int i = imin_in; i < iarray.current_extent(); i++){
                            object_for_base_t< ARITY, ITYPE, IRANK - 1, ISYM, FIRANK, ICOM, OTYPE, ORANK - 1, OSYM, FORANK, OMP_LEVELS, DEPTH + 1
                                > next(func_in, i);
                            next(iarray(i), oarray(i));
                        }
                    };
                }
            } else {
                if constexpr (OMP_LEVELS != 0) {
                    this->loop = [func_in, imin_in](nested_array_t<ITYPE, IRANK, ISYM> iarray, nested_array_t<OTYPE, ORANK, OSYM> oarray){
                        #pragma omp parallel for
                        for(int i = imin_in; i < iarray.current_extent(); i++){
                            object_for_base_t< ARITY, ITYPE, IRANK - 1, ISYM, FIRANK, ICOM, OTYPE, ORANK - 1, OSYM, FORANK, OMP_LEVELS - 1, DEPTH + 1
                                > next(func_in);
                            next(iarray(i), oarray(i));
                        }
                    };
                } else {
                    this->loop = [func_in, imin_in](nested_array_t<ITYPE, IRANK, ISYM> iarray, nested_array_t<OTYPE, ORANK, OSYM> oarray){
                        for(int i = imin_in; i < iarray.current_extent(); i++){
                            object_for_base_t< ARITY, ITYPE, IRANK - 1, ISYM, FIRANK, ICOM, OTYPE, ORANK - 1, OSYM, FORANK, OMP_LEVELS, DEPTH + 1
                                > next(func_in);
                            next(iarray(i), oarray(i));
                        }
                    };
                }
            }

        }

    }

}

template<const int ARITY, typename ITYPE, const int IRANK, const int* ISYM, const int FIRANK, const int* ICOM,
                          typename OTYPE, const int ORANK, const int* OSYM, const int FORANK, const int OMP_LEVELS,
                          const int DEPTH>
std::function<void(nested_array_t<ITYPE, IRANK, ISYM>, nested_array_t<OTYPE, ORANK, OSYM>)>
object_for_base_t<ARITY, ITYPE, IRANK, ISYM, FIRANK, ICOM, OTYPE, ORANK, OSYM, FORANK, OMP_LEVELS, DEPTH>::operator()(){
    return [this](nested_array_t<ITYPE, IRANK, ISYM> iarray, nested_array_t<OTYPE, ORANK, OSYM> oarray){this->loop(iarray, oarray);};
}

template<const int ARITY, typename ITYPE, const int IRANK, const int* ISYM, const int FIRANK, const int* ICOM,
                          typename OTYPE, const int ORANK, const int* OSYM, const int FORANK, const int OMP_LEVELS,
                          const int DEPTH>
void object_for_base_t<ARITY, ITYPE, IRANK, ISYM, FIRANK, ICOM, OTYPE, ORANK, OSYM, FORANK, OMP_LEVELS, DEPTH>::operator()(nested_array_t<ITYPE, IRANK, ISYM> iarray_in, nested_array_t<OTYPE, ORANK, OSYM> oarray_in){
    this->loop(iarray_in, oarray_in);
    return;
}

/** The object_for loop is a grammatical orientation of the nested_for loop that allows you to tie an
 *  iteration pattern to a function, and later pass it input and output arrays for the function to evaluate.
 *  This is useful for evaluating a function as applied to multiple different input arrays of arbitrary
 *  shape and dimensionality.
 *
 *  object_for loops also support symmetry optimization. The best way to structure data for symmetry
 *  optimization is all symmetric dimensions in a symmetry group are sequential. Mixed grouping will
 *  break this optimization.
 *
 * @tparam NITYPE       The input array type.
 * @tparam NOTYPE       The output array type.
 * @tparam CLTYPE       The closure type.
 * @tparam OMP_LEVELS   The number of dimensions to parallelize with OpenMP. This will apply to the first
 *                      OMP_LEVELS dimensions.
 */
template<typename NITYPE, typename NOTYPE, typename CLTYPE, const int OMP_LEVELS = 0>
class object_for_t : public object_for_base_t<CLTYPE::arity, typename NITYPE::value_type, NITYPE::rank, NITYPE::symmetry, CLTYPE::input_rank, CLTYPE::commutativity,
                                                             typename NOTYPE::value_type, NOTYPE::rank, NOTYPE::symmetry, CLTYPE::output_rank, OMP_LEVELS>{
              public: using object_for_base_t<CLTYPE::arity, typename NITYPE::value_type, NITYPE::rank, NITYPE::symmetry, CLTYPE::input_rank, CLTYPE::commutativity,
                                                             typename NOTYPE::value_type, NOTYPE::rank, NOTYPE::symmetry, CLTYPE::output_rank, OMP_LEVELS>::object_for_base_t;
};




/** Pure object_for loop. This is composable with other object_for loops and omp_object_for loops. */
template<typename ITYPE, const int IRANK, const int* ISYM, typename OTYPE, const int ORANK, const int* OSYM, typename FTYPE>
std::function<void(nested_array_t<ITYPE, IRANK, ISYM>, nested_array_t<OTYPE, ORANK, OSYM>)> object_for(FTYPE func_in){

    std::function<void(nested_array_t<ITYPE, IRANK, ISYM>, nested_array_t<OTYPE, ORANK, OSYM>)> retfunc =
    [func_in](nested_array_t<ITYPE, IRANK, ISYM> array_in, nested_array_t<OTYPE, ORANK, OSYM> array_out){

        for(int i = 0; i < array_in.current_extent(); i++){
            func_in(array_in(i), array_out(i));
        }

    };
    return retfunc;
}

/** Pure object_for loop parallelized with OpenMP. This is composable with object_for loops and other omp_object_for loops. */
template<typename ITYPE, const int IRANK, const int* ISYM, typename OTYPE, const int ORANK, const int* OSYM, typename FTYPE>
std::function<void(nested_array_t<ITYPE, IRANK, ISYM>, nested_array_t<OTYPE, ORANK, OSYM>)> omp_object_for(FTYPE func_in){

    std::function<void(nested_array_t<ITYPE, IRANK, ISYM>, nested_array_t<OTYPE, ORANK, OSYM>)> retfunc =
    [func_in](nested_array_t<ITYPE, IRANK, ISYM> array_in, nested_array_t<OTYPE, ORANK, OSYM> array_out){

        #pragma omp parallel for
        for(int i = 0; i < array_in.current_extent(); i++){
            func_in(array_in(i), array_out(i));
        }

    };
    return retfunc;
}


#endif

#ifndef METHOD_FOR_CPP
#define METHOD_FOR_CPP

#include <functional>
#include <type_traits>

#include "nested_array.cpp"
#include "curry.cpp"
#include "closure.cpp"

using std::add_pointer;
using std::remove_pointer;

//-----------------------------------------------------------------------//
//
// To any who dare tread here: I recommend running away, flailing wildly,
// and/or hysterical screaming. If you are not afraid, you should be.
//
//-----------------------------------------------------------------------//

/** The method_for loop is a grammatical orientation of the nested_for loop that allows you to tie an
 *  iteration pattern to an input array, and later pass it an output array and  a function to evaluate
 *  with the data. This is useful for evaluating several different functions (with the same input/output
 *  types) over an input array of arbitrary shape and dimensionality.
 *
 *  Nested_for loops create the iteration pattern for a given input and output array by indexing down into
 *  both input and output arrays until the output array rank matches the function output array rank. From
 *  there, they continue indexing down into the input array, passing along the final output array. When the
 *  input array rank matches the function input array rank, we call the function. Nested_for loops can be
 *  understood as a kind of branchy combinator that nests for loops inside each other.
 *
 *  Each class specialization is generated by recursively instantiating method_for_base_t functors as it
 *  decrements the array rank(s) it's working with. Beware: if the function type never matches the combo
 *  of dereferenced array types, you will get an infinite loop at compile time! However, *all* needed class
 *  specializations must be available at runtime, so all logic in choosing the correct loop, including all
 *  subsequent specializations required due to the type cascade, must be completed at compile time.
 *
 *  Only the top-level object is created upon loop declaration by the user. Calling the function operator
 *  (i.e., '()' ) kicks off a cascade of object creations, where all the other loops are actually generated.
 *  Thus, the compile-time logic only chooses the correct loop type; the runtime is responsible for deciding
 *  the iteration bounds for each loop, and actually launching it.
 *
 *  Nested_for loops support symmetry optimization. The best way to structure data for symmetry
 *  optimization is to ensure that all symmetric dimensions in a symmetry group are sequential. Mixed
 *  grouping will break this optimization. A 1-D array of arbitrary integers; equal values
 *  imply symmetry between different dimensions.
 *
 * @tparam ARITY    The number of arguments the function will accept. In other words, the function will
 *                  require this many elements from the input array to be calculated.
 * @tparam ITYPE    The input array's value type.
 * @tparam IRANK    The rank (or dimensionality) of the input array.
 * @tparam ISYM     The input array's symmetry vector.
 * @tparam FIRANK   The rank (or dimensionality) of array that will be passed to the function as input.
 * @tparam ICOM     The function's commutativity vector.
 * @tparam OTYPE    The output array's value type.
 * @tparam ORANK    The rank (or dimensionality) of the output array.
 * @tparam OSYM     The output array's symmetry vector.
 * @tparam FORANK   The rank (or dimensionality) of array that will be passed to the function as output.
 * @tparam FOTYPE   The function ouput type.
 * @tparam OMP_LEVELS   The number of dimensions to parallelize with OpenMP. This will apply to the first
 *                      OMP_LEVELS dimensions.
 * @tparam DEPTH    How deep we currently are in the input array. Only needed to assist with symmetry
 *                  optimization; this is only for use within this class and should not be set in
 *                  implementations.
 *
 * @typedef FTYPE   The function type.
 *
 * @param loop      Stores a lambda function that iterates through the input array's top-level dimension,
 *                  and spawns new method_for_base_t objects to continue traversal when called. At the lowest
 *                  level, it stores a lambda function that simply calls the function on the data. method_for
 *                  loops have a recursive function type that nests with input array rank.
 */
template<const int ARITY, typename ITYPE, const int IRANK, const int* ISYM, const int  FIRANK, const int* ICOM,
                          typename OTYPE, const int ORANK, const int* OSYM, const int  FORANK, const int OMP_LEVELS = 0,
                          const int DEPTH = 0>
class method_for_base_t {

    typedef const void (FTYPE)(nested_array_t<ITYPE, FIRANK, ISYM>, nested_array_t<OTYPE, FORANK, OSYM>);

    std::function<void(FTYPE, nested_array_t<OTYPE, ORANK, OSYM>)> loop;

public:
    method_for_base_t(nested_array_t<ITYPE, IRANK, ISYM> iarray_in, const int imin = 0);
    ~method_for_base_t(){};

    std::function<void(FTYPE, nested_array_t<OTYPE, ORANK, OSYM>)> operator()() const;
    void operator()(FTYPE func_in, nested_array_t<OTYPE, ORANK, OSYM> oarray_in) const;

};

template<const int ARITY, typename ITYPE, const int IRANK, const int* ISYM, const int  FIRANK, const int* ICOM,
                          typename OTYPE, const int ORANK, const int* OSYM, const int  FORANK, const int OMP_LEVELS,
                          const int DEPTH>
method_for_base_t<ARITY, ITYPE, IRANK, ISYM, FIRANK, ICOM, OTYPE, ORANK, OSYM, FORANK, OMP_LEVELS, DEPTH>::method_for_base_t(nested_array_t<ITYPE, IRANK, ISYM> iarray_in, const int imin_in){

    // Are we done appending loops?
    if constexpr (IRANK == FIRANK){

        this->loop = [iarray_in](FTYPE func, nested_array_t<OTYPE, ORANK, OSYM> oarray){
            func(iarray_in, oarray);
        };

    } else {

        // Are we done stripping off output dimensions?
        if constexpr (ORANK == FORANK){

            // Is this dimension symmetric with the next one?
            if constexpr (ISYM && DEPTH < IRANK - FIRANK && ISYM[DEPTH] == ISYM[DEPTH + 1]){
                if constexpr (OMP_LEVELS != 0) {
                    this->loop = [iarray_in, imin_in](FTYPE func, nested_array_t<OTYPE, ORANK, OSYM> oarray){
                        #pragma omp parallel for
                        for(int i = imin_in; i < iarray_in.current_extent(); i++){
                            method_for_base_t< ARITY, ITYPE, IRANK - 1, ISYM, FIRANK, ICOM, OTYPE, ORANK, OSYM, FORANK, OMP_LEVELS - 1, DEPTH + 1
                                > next(iarray_in(i), i);
                            next(func, oarray);
                        }
                    };
                } else {
                    this->loop = [iarray_in, imin_in](FTYPE func, nested_array_t<OTYPE, ORANK, OSYM> oarray){
                        for(int i = imin_in; i < iarray_in.current_extent(); i++){
                            method_for_base_t< ARITY, ITYPE, IRANK - 1, ISYM, FIRANK, ICOM, OTYPE, ORANK, OSYM, FORANK, OMP_LEVELS, DEPTH + 1
                                > next(iarray_in(i), i);
                            next(func, oarray);
                        }
                    };
                }
            } else {
                if constexpr (OMP_LEVELS != 0) {
                    this->loop = [iarray_in, imin_in](FTYPE func, nested_array_t<OTYPE, ORANK, OSYM> oarray){
                        #pragma omp parallel for
                        for(int i = imin_in; i < iarray_in.current_extent(); i++){
                            method_for_base_t< ARITY, ITYPE, IRANK - 1, ISYM, FIRANK, ICOM, OTYPE, ORANK, OSYM, FORANK, OMP_LEVELS - 1, DEPTH + 1
                                > next(iarray_in(i));
                            next(func, oarray);
                        }
                    };
                } else {
                    this->loop = [iarray_in, imin_in](FTYPE func, nested_array_t<OTYPE, ORANK, OSYM> oarray){
                        for(int i = imin_in; i < iarray_in.current_extent(); i++){
                            method_for_base_t< ARITY, ITYPE, IRANK - 1, ISYM, FIRANK, ICOM, OTYPE, ORANK, OSYM, FORANK, OMP_LEVELS, DEPTH + 1
                                > next(iarray_in(i));
                            next(func, oarray);
                        }
                    };
                }
            }

        }else{

            // Is this dimension symmetric with the next one?
            if constexpr (ISYM && DEPTH < IRANK - FIRANK && ISYM[DEPTH] == ISYM[DEPTH + 1]){
                if constexpr (OMP_LEVELS != 0) {
                    this->loop = [iarray_in, imin_in](FTYPE func, nested_array_t<OTYPE, ORANK, OSYM> oarray){
                        #pragma omp parallel for
                        for(int i = imin_in; i < iarray_in.current_extent(); i++){
                            method_for_base_t< ARITY, ITYPE, IRANK - 1, ISYM, FIRANK, ICOM, OTYPE, ORANK - 1, OSYM, FORANK, OMP_LEVELS - 1, DEPTH + 1
                                > next(iarray_in(i), i);
                            next(func, oarray(i));
                        }
                    };
                } else {
                    this->loop = [iarray_in, imin_in](FTYPE func, nested_array_t<OTYPE, ORANK, OSYM> oarray){
                        for(int i = imin_in; i < iarray_in.current_extent(); i++){
                            method_for_base_t< ARITY, ITYPE, IRANK - 1, ISYM, FIRANK, ICOM, OTYPE, ORANK - 1, OSYM, FORANK, OMP_LEVELS, DEPTH + 1
                                > next(iarray_in(i), i);
                            next(func, oarray(i));
                        }
                    };
                }
            } else {
                if constexpr (OMP_LEVELS != 0) {
                    this->loop = [iarray_in, imin_in](FTYPE func, nested_array_t<OTYPE, ORANK, OSYM> oarray){
                        #pragma omp parallel for
                        for(int i = imin_in; i < iarray_in.current_extent(); i++){
                            method_for_base_t< ARITY, ITYPE, IRANK - 1, ISYM, FIRANK, ICOM, OTYPE, ORANK - 1, OSYM, FORANK, OMP_LEVELS - 1, DEPTH + 1
                                > next(iarray_in(i));
                            next(func, oarray(i));
                        }
                    };
                } else {
                    this->loop = [iarray_in, imin_in](FTYPE func, nested_array_t<OTYPE, ORANK, OSYM> oarray){
                        for(int i = imin_in; i < iarray_in.current_extent(); i++){
                            method_for_base_t< ARITY, ITYPE, IRANK - 1, ISYM, FIRANK, ICOM, OTYPE, ORANK - 1, OSYM, FORANK, OMP_LEVELS, DEPTH + 1
                                > next(iarray_in(i));
                            next(func, oarray(i));
                        }
                    };
                }
            }

        }

    }

}

template<const int ARITY, typename ITYPE, const int IRANK, const int* ISYM, const int  FIRANK, const int* ICOM,
                          typename OTYPE, const int ORANK, const int* OSYM, const int  FORANK, const int OMP_LEVELS,
                          const int DEPTH>
std::function<void(const void(*)(nested_array_t<ITYPE, FIRANK, ISYM>, nested_array_t<OTYPE, FORANK, OSYM>), nested_array_t<OTYPE, ORANK, OSYM>)>
method_for_base_t<ARITY, ITYPE, IRANK, ISYM, FIRANK, ICOM, OTYPE, ORANK, OSYM, FORANK, OMP_LEVELS, DEPTH>::operator()() const {
    return [this](FTYPE func, nested_array_t<OTYPE, ORANK, OSYM> oarray){this->loop(func, oarray);};
}

template<const int ARITY, typename ITYPE, const int IRANK, const int* ISYM, const int  FIRANK, const int* ICOM,
                          typename OTYPE, const int ORANK, const int* OSYM, const int  FORANK, const int OMP_LEVELS,
                          const int DEPTH>
void method_for_base_t<ARITY, ITYPE, IRANK, ISYM, FIRANK, ICOM, OTYPE, ORANK, OSYM, FORANK, OMP_LEVELS, DEPTH>::operator()(FTYPE func_in, nested_array_t<OTYPE, ORANK, OSYM> oarray_in) const {
    this->loop(func_in, oarray_in);
    return;
}

/** The method_for loop is a grammatical orientation of the nested_for loop that allows you to tie an
 *  iteration pattern to an input array, and later pass it an output array and  a function to evaluate
 *  with the data. This is useful for evaluating several different functions (with the same input/output
 *  types) over an input array of arbitrary shape and dimensionality.
 *
 *  method_for loops support symmetry optimization. The best way to structure data for symmetry
 *  optimization is to ensure that all symmetric dimensions in a symmetry group are sequential. Mixed
 *  grouping will break this optimization. A 1-D array of arbitrary integers; equal values
 *  imply symmetry between different dimensions.
 *
 * @tparam NITYPE       The input array type.
 * @tparam NOTYPE       The output array type.
 * @tparam CLTYPE       The closure type.
 * @tparam OMP_LEVELS   The number of dimensions to parallelize with OpenMP. This will apply to the first
 *                      OMP_LEVELS dimensions.
 */
template<typename NITYPE, typename NOTYPE, typename CLTYPE, const int OMP_LEVELS = 0>
class method_for_t : public method_for_base_t<CLTYPE::arity, typename NITYPE::value_type, NITYPE::rank, NITYPE::symmetry, CLTYPE::input_rank, CLTYPE::commutativity,
                                                             typename NOTYPE::value_type, NOTYPE::rank, NOTYPE::symmetry, CLTYPE::output_rank, OMP_LEVELS>{
              public: using method_for_base_t<CLTYPE::arity, typename NITYPE::value_type, NITYPE::rank, NITYPE::symmetry, CLTYPE::input_rank, CLTYPE::commutativity,
                                                             typename NOTYPE::value_type, NOTYPE::rank, NOTYPE::symmetry, CLTYPE::output_rank, OMP_LEVELS>::method_for_base_t;
};

#endif

/***********************************************************************
 *                   GNU Lesser General Public License
 *
 * This file is part of the EDGI package, developed by the
 * GFDL Flexible Modeling System (FMS) group.
 *
 * EDGI is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at
 * your option) any later version.
 *
 * EDGI is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with EDGI.  If not, see <http://www.gnu.org/licenses/>.
 **********************************************************************/

#ifndef METHOD_FOR_CPP
#define METHOD_FOR_CPP

#include <functional>
#include <tuple>
#include <type_traits>

#include "nested_array.cpp"
#include "closure.cpp"

using std::add_pointer;
using std::remove_pointer;
using std::tuple;

//-----------------------------------------------------------------------//
//
// To any who dare tread here: I recommend running away, flailing wildly,
// and/or hysterical screaming. If you are not afraid, you should be.
//
//-----------------------------------------------------------------------//


/** The method_for loop is a grammatical orientation of the nested_for loop that allows you to tie an
 *  iteration pattern to an input array, and later pass it an output array and  a function to evaluate
 *  with the data. This is useful for evaluating several different functions (with the same input/output
 *  types) over an input array of arbitrary shape and dimensionality.
 *
 *  Nested_for loops create the iteration pattern for a given input and output array by indexing down into
 *  both input and output arrays until the output array rank matches the function output array rank. From
 *  there, they continue indexing down into the input array, passing along the final output array. When the
 *  input array rank matches the function input array rank, we call the function. Nested_for loops can be
 *  understood as a kind of branchy combinator that nests for loops inside each other.
 *
 *  Each class specialization is generated by recursively instantiating method_for_impl lambdas as it
 *  decrements the array rank(s) it's working with. Beware: if the function type never matches the combo
 *  of dereferenced array types, you will get an infinite loop at compile time! However, *all* needed class
 *  specializations must be available at runtime, so all logic in choosing the correct loop, including all
 *  subsequent specializations required due to the type cascade, must be completed at compile time.
 *
 *  Only the top-level object is created upon loop declaration by the user. Calling the function operator
 *  (i.e., '()' ) kicks off a cascade of object creations, where all the other loops are actually generated.
 *  Thus, the compile-time logic only chooses the correct loop type; the runtime is responsible for deciding
 *  the iteration bounds for each loop, and actually launching it.
 *
 *  Nested_for loops support symmetry optimization. The best way to structure data for symmetry
 *  optimization is to ensure that all symmetric dimensions in a symmetry group are sequential. Mixed
 *  grouping will break this optimization. A 1-D array of arbitrary integers; equal values
 *  imply symmetry between different dimensions.
 *
 * @tparam ITYPE    The input array's value type.
 * @tparam IRANK    The rank (or dimensionality) of the input array.
 * @tparam ISYM     The input array's symmetry vector.
 * @tparam FIRANK   The rank (or dimensionality) of array that will be passed to the function as input.
 * @tparam OTYPE    The output array's value type.
 * @tparam ORANK    The rank (or dimensionality) of the output array.
 * @tparam FORANK   The rank (or dimensionality) of array that will be passed to the function as output.
 * @tparam OMP_LEVELS   The number of dimensions to parallelize with OpenMP. This will apply to the first
 *                      OMP_LEVELS dimensions.
 * @tparam DEPTH    How deep we currently are in the input array. Only needed to assist with symmetry
 *                  optimization; this is only for use within this class and should not be set in external
 *                  implementations.
 *
 * @typedef FTYPE   The function type.
 *
 * @return          A lambda function that iterates through the input array's top-level dimension,
 *                  and spawns new method_for objects to continue traversal when called. At the lowest
 *                  level, it stores a lambda function that simply calls the function on the data. method_for
 *                  loops have a recursive function type that nests with input array rank.
 */
template<typename ITYPE, const int IRANK, const int* ISYM, const int FIRANK,
         typename OTYPE, const int ORANK,                  const int FORANK,
         const int OMP_LEVELS = 0, const int DEPTH = 0>
constexpr auto method_for_impl(nested_array_t<ITYPE, IRANK, ISYM> iarray_in, const int imin_in = 0){

    typedef const void (FTYPE)(nested_array_t<ITYPE, FIRANK, ISYM>, nested_array_t<OTYPE, FORANK>);
    //typedef const closure_base_t<1, ITYPE, FIRANK, OTYPE, FORANK> closure_t;

    // Are we done appending loops?
    if constexpr (IRANK == FIRANK) {

        return [iarray_in](FTYPE func, nested_array_t<OTYPE, ORANK> oarray) {
            func(iarray_in, oarray);
        };

    } else if constexpr (IRANK > FIRANK) {

        return [iarray_in, imin_in](FTYPE func, nested_array_t<OTYPE, ORANK> oarray) {

            if constexpr (DEPTH == 0) {
                for (int i = 0; i < IRANK - FIRANK; i++) {
                    oarray.set_extent(i, iarray_in.extent(i));
                }
            }

            auto loop = [func, iarray_in, oarray](int i){
                // Is this dimension symmetric with the next one?
                if constexpr (ISYM && DEPTH < IRANK - FIRANK && ISYM[DEPTH] == ISYM[DEPTH + 1]){
                    // Are we done stripping off output dimensions?
                    if constexpr (ORANK == FORANK) {
                        method_for_impl<ITYPE, IRANK - 1, ISYM, FIRANK, OTYPE, ORANK,     FORANK, OMP_LEVELS - 1, DEPTH + 1>(iarray_in(i), i)(func, oarray);
                    } else {
                        method_for_impl<ITYPE, IRANK - 1, ISYM, FIRANK, OTYPE, ORANK - 1, FORANK, OMP_LEVELS - 1, DEPTH + 1>(iarray_in(i), i)(func, oarray(i));
                    }
                } else {
                    if constexpr (ORANK == FORANK) {
                        method_for_impl<ITYPE, IRANK - 1, ISYM, FIRANK, OTYPE, ORANK,     FORANK, OMP_LEVELS - 1, DEPTH + 1>(iarray_in(i))(func, oarray);
                    } else {
                        method_for_impl<ITYPE, IRANK - 1, ISYM, FIRANK, OTYPE, ORANK - 1, FORANK, OMP_LEVELS - 1, DEPTH + 1>(iarray_in(i))(func, oarray(i));
                    }
                }
            };

            if constexpr (OMP_LEVELS > 0) {
                int i = imin_in;
                #pragma omp parallel for private(i)
                for (i = imin_in; i < iarray_in.current_extent(); i++) {
                    loop(i);
                }
            } else { // if constexpr (OMP_LEVELS == 0)
                for (int i = imin_in; i < iarray_in.current_extent(); i++) {
                    loop(i);
                }
            }

        };

    }

}

/** The method_for loop is a grammatical orientation of the nested_for loop that allows you to tie an
 *  iteration pattern to an input array, and later pass it an output array and  a function to evaluate
 *  with the data. This is useful for evaluating several different functions (with the same input/output
 *  types) over an input array of arbitrary shape and dimensionality.
 *
 *  method_for loops support symmetry optimization. The best way to structure data for symmetry
 *  optimization is to ensure that all symmetric dimensions in a symmetry group are sequential. Mixed
 *  grouping will break this optimization. A 1-D array of arbitrary integers; equal values
 *  imply symmetry between different dimensions.
 *
 * @tparam NITYPE       The input array type.
 * @tparam NOTYPE       The output array type.
 * @tparam CLTYPE       The closure type.
 * @tparam OMP_LEVELS   The number of dimensions to parallelize with OpenMP. This will apply to the first
 *                      OMP_LEVELS dimensions.
 *
 * @return          A lambda function that iterates through the input array's top-level dimension,
 *                  and spawns new method_for objects to continue traversal when called. At the lowest
 *                  level, it stores a lambda function that simply calls the function on the data. method_for
 *                  loops have a recursive function type that nests with input array rank.
 */
template<typename NITYPE, typename NOTYPE, typename CLTYPE, const int OMP_LEVELS = 0>
constexpr auto method_for(NITYPE iarray_in){
    return method_for_impl<typename NITYPE::value_type, NITYPE::rank, NITYPE::symmetry, CLTYPE::input_rank,
                           typename NOTYPE::value_type, NOTYPE::rank,                   CLTYPE::output_rank,
                           OMP_LEVELS>(iarray_in);
}







template<typename TUITYPE, typename NOTYPE, typename CLTYPE, const int OMP_LEVELS = 0, const int ARG = 0>
constexpr auto method_for_chained(TUITYPE iarrays_in){

    static_assert(std::tuple_size<TUITYPE>::value == CLTYPE::arity);
    typedef typename std::tuple_element<ARG, TUITYPE>::type ITYPE;

    if constexpr (std::tuple_size<TUITYPE>::value == ARG - 1) {

        return [iarrays_in](typename CLTYPE::ftype func, NOTYPE oarray) {
            func(std::get<ARG>(iarrays_in), oarray);
        };

    } else {

        return [iarrays_in](typename CLTYPE::ftype func, NOTYPE oarray){
            auto loop = method_for_impl<ITYPE::value_type, ITYPE::rank, ITYPE::symmetry, CLTYPE::input_rank,
                                        typename NOTYPE::value_type, NOTYPE::rank, CLTYPE::output_rank,
                                        OMP_LEVELS
                    >(std::get<ARG>(iarrays_in));

            loop(method_for_chained<TUITYPE, NOTYPE, CLTYPE, OMP_LEVELS>(iarrays_in)(func, oarray));
        };

    }

}



#endif

/***********************************************************************
 *                   GNU Lesser General Public License
 *
 * This file is part of the EDGI package, developed by the
 * GFDL Flexible Modeling System (FMS) group.
 *
 * EDGI is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at
 * your option) any later version.
 *
 * EDGI is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with EDGI.  If not, see <http://www.gnu.org/licenses/>.
 **********************************************************************/

#ifndef METHOD_FOR_CPP
#define METHOD_FOR_CPP

#include <functional>
#include <omp.h>
#include <openacc.h>
#include <tuple>
#include <type_traits>

#include "nested_netcdf_array.cpp"
#include "nested_array.cpp"
#include "closure.cpp"

using std::add_pointer;
using std::remove_pointer;
using std::tuple;

//-----------------------------------------------------------------------//
//
// To any who dare tread here: I recommend running away, flailing wildly,
// and/or hysterical screaming. If you are not afraid, you should be.
//
//-----------------------------------------------------------------------//


/** The method_for loop is a grammatical orientation of the nested_for loop that allows you to tie an
 *  iteration pattern to an input array, and later pass it an output array and  a function to evaluate
 *  with the data. This is useful for evaluating several different functions (with the same input/output
 *  types) over an input array of arbitrary shape and dimensionality.
 *
 *  Nested_for loops create the iteration pattern for a given input and output array by indexing down into
 *  both input and output arrays until the output array rank matches the function output array rank. From
 *  there, they continue indexing down into the input array, passing along the final output array. When the
 *  input array rank matches the function input array rank, we call the function. Nested_for loops can be
 *  understood as a kind of branchy combinator that nests for loops inside each other.
 *
 *  Each class specialization is generated by recursively instantiating method_for_impl lambdas as it
 *  decrements the array rank(s) it's working with. Beware: if the function type never matches the combo
 *  of dereferenced array types, you will get an infinite loop at compile time! However, *all* needed class
 *  specializations must be available at runtime, so all logic in choosing the correct loop, including all
 *  subsequent specializations required due to the type cascade, must be completed at compile time.
 *
 *  Only the top-level object is created upon loop declaration by the user. Calling the function operator
 *  (i.e., '()' ) kicks off a cascade of object creations, where all the other loops are actually generated.
 *  Thus, the compile-time logic only chooses the correct loop type; the runtime is responsible for deciding
 *  the iteration bounds for each loop, and actually launching it.
 *
 *  Nested_for loops support symmetry optimization. The best way to structure data for symmetry
 *  optimization is to ensure that all symmetric dimensions in a symmetry group are sequential. Mixed
 *  grouping will break this optimization. A 1-D array of arbitrary integers; equal values
 *  imply symmetry between different dimensions.
 *
 * @tparam ITYPE    The input array's value type.
 * @tparam IRANK    The rank (or dimensionality) of the input array.
 * @tparam ISYM     The input array's symmetry vector.
 * @tparam FIRANK   The rank (or dimensionality) of array that will be passed to the function as input.
 * @tparam OTYPE    The output array's value type.
 * @tparam ORANK    The rank (or dimensionality) of the output array.
 * @tparam FORANK   The rank (or dimensionality) of array that will be passed to the function as output.
 * @tparam OMP_LEVELS   The number of dimensions to parallelize with OpenMP. This will apply to the first
 *                      OMP_LEVELS dimensions.
 * @tparam DEPTH    How deep we currently are in the input array. Only needed to assist with symmetry
 *                  optimization; this is only for use within this class and should not be set in external
 *                  implementations.
 *
 * @typedef FTYPE   The function type.
 *
 * @return          A lambda function that iterates through the input array's top-level dimension,
 *                  and spawns new method_for objects to continue traversal when called. At the lowest
 *                  level, it stores a lambda function that simply calls the function on the data. method_for
 *                  loops have a recursive function type that nests with input array rank.
 */
template<typename ITYPE, const int IRANK, const int* ISYM, const int FIRANK,
         typename OTYPE, const int ORANK,                  const int FORANK,
         const int OMP_LEVELS = 0, const bool IN_OMP_REGION, const bool ACC_ON, const int DEPTH = 0>
constexpr auto method_for_impl(nested_array_t<ITYPE, IRANK, ISYM> iarray_in, const int imin_in = 0){

    typedef const void (FTYPE)(nested_array_t<ITYPE, FIRANK, ISYM>, nested_array_t<OTYPE, FORANK>);
    //typedef const closure_base_t<1, ITYPE, FIRANK, OTYPE, FORANK> closure_t;

    // Are we done appending loops?
    if constexpr (IRANK == FIRANK) {

        return [iarray_in](FTYPE func, nested_array_t<OTYPE, ORANK> oarray) {
            func(iarray_in, oarray);
        };

    } else if constexpr (IRANK > FIRANK) {

        return [iarray_in, imin_in](FTYPE func, nested_array_t<OTYPE, ORANK> oarray) {

            if constexpr (DEPTH == 0) {
                for (int i = 0; i < IRANK - FIRANK; i++) {
                    oarray.set_extent(i, iarray_in.extent(i));
                }
            }

            auto loop = [func, iarray_in, oarray](int i){
                if constexpr (OMP_LEVELS > 0 || IN_OMP_REGION) {
                    // Is this dimension symmetric with the next one?
                    if constexpr (ISYM && DEPTH < IRANK - FIRANK && ISYM[DEPTH] == ISYM[DEPTH + 1]){
                        // Are we done stripping off output dimensions?
                        if constexpr (ORANK == FORANK) {
                            method_for_impl<ITYPE, IRANK - 1, ISYM, FIRANK, OTYPE, ORANK,     FORANK, OMP_LEVELS - 1, true, ACC_ON, DEPTH + 1>(iarray_in(i), i)(func, oarray);
                        } else {
                            method_for_impl<ITYPE, IRANK - 1, ISYM, FIRANK, OTYPE, ORANK - 1, FORANK, OMP_LEVELS - 1, true, ACC_ON, DEPTH + 1>(iarray_in(i), i)(func, oarray(i));
                        }
                    } else {
                        if constexpr (ORANK == FORANK) {
                            method_for_impl<ITYPE, IRANK - 1, ISYM, FIRANK, OTYPE, ORANK,     FORANK, OMP_LEVELS - 1, true, ACC_ON, DEPTH + 1>(iarray_in(i))(func, oarray);
                        } else {
                            method_for_impl<ITYPE, IRANK - 1, ISYM, FIRANK, OTYPE, ORANK - 1, FORANK, OMP_LEVELS - 1, true, ACC_ON, DEPTH + 1>(iarray_in(i))(func, oarray(i));
                       }
                   }
                } else {
                    // Is this dimension symmetric with the next one?
                    if constexpr (ISYM && DEPTH < IRANK - FIRANK && ISYM[DEPTH] == ISYM[DEPTH + 1]){
                        // Are we done stripping off output dimensions?
                        if constexpr (ORANK == FORANK) {
                            method_for_impl<ITYPE, IRANK - 1, ISYM, FIRANK, OTYPE, ORANK,     FORANK, OMP_LEVELS - 1, false, ACC_ON, DEPTH + 1>(iarray_in(i), i)(func, oarray);
                        } else {
                            method_for_impl<ITYPE, IRANK - 1, ISYM, FIRANK, OTYPE, ORANK - 1, FORANK, OMP_LEVELS - 1, false, ACC_ON, DEPTH + 1>(iarray_in(i), i)(func, oarray(i));
                        }
                    } else {
                        if constexpr (ORANK == FORANK) {
                            method_for_impl<ITYPE, IRANK - 1, ISYM, FIRANK, OTYPE, ORANK,     FORANK, OMP_LEVELS - 1, false, ACC_ON, DEPTH + 1>(iarray_in(i))(func, oarray);
                        } else {
                            method_for_impl<ITYPE, IRANK - 1, ISYM, FIRANK, OTYPE, ORANK - 1, FORANK, OMP_LEVELS - 1, false, ACC_ON, DEPTH + 1>(iarray_in(i))(func, oarray(i));
                       }
                   }
                }
            };

            if constexpr (ACC_ON && IRANK == FIRANK + 1) {
                if constexpr (OMP_LEVELS > 0) {
                    //failboat
                } else {
                    int gpu_id = omp_get_thread_num() %% acc_get_num_devices(acc_device_default);
                    acc_set_device_num(gpu_id, acc_device_default);
                    
                    for (int i = imin_in; i < iarray_in.current_extent(); i++) {
                        loop(i);
                    }
                }
                     
            } else {
                if constexpr (OMP_LEVELS > 0) {
                    int i = imin_in;
                    #pragma omp parallel for private(i)
                    for (i = imin_in; i < iarray_in.current_extent(); i++) {
                        loop(i);
                    }
                } else { // if constexpr (OMP_LEVELS == 0)
                    for (int i = imin_in; i < iarray_in.current_extent(); i++) {
                        loop(i);
                    }
                }
            }
        };

    }

}

/*
template<typename ITYPE, const int IRANK, const char IFNAME[], const char IVNAME[], const int* ISYM, const int FIRANK,
         typename OTYPE, const int ORANK, const char OFNAME[], const char OVNAME[],                  const int FORANK,
         const int OMP_LEVELS = 0, const int DEPTH = 0>
constexpr auto method_for_nc_impl(nested_netcdf_array_t<ITYPE, IRANK, IFNAME, IVNAME, ISYM> iarray_in, const int imin_in = 0){

    typedef const void (FTYPE)(nested_netcdf_array_t<ITYPE, FIRANK, IFNAME, IVNAME, ISYM>, nested_netcdf_array_t<OTYPE, FORANK, OFNAME, OVNAME>);
    //typedef const closure_base_t<1, ITYPE, FIRANK, OTYPE, FORANK> closure_t;

    // Are we done appending loops?
    if constexpr (IRANK == FIRANK) {

        return [iarray_in](FTYPE func, nested_netcdf_array_t<OTYPE, ORANK, OFNAME, OVNAME> oarray) {
            iarray_in.read();
            func(iarray_in, oarray);
            oarray.write();
        };

    } else if constexpr (IRANK > FIRANK) {

        auto mloop = [iarray_in, imin_in](FTYPE func, nested_netcdf_array_t<OTYPE, ORANK, OFNAME, OVNAME> oarray) {

            auto loop = [func, iarray_in, oarray](int i){
                // Is this dimension symmetric with the next one?
                if constexpr (ISYM && DEPTH < IRANK - FIRANK && ISYM[DEPTH] == ISYM[DEPTH + 1]){
                    // Are we done stripping off output dimensions?
                    if constexpr (ORANK == FORANK) {
                        method_for_nc_impl<ITYPE, IRANK - 1, IFNAME, IVNAME, ISYM, FIRANK, OTYPE, ORANK,     OFNAME, OVNAME, FORANK, OMP_LEVELS - 1, DEPTH + 1>(iarray_in(i), i)(func, oarray);
                    } else {
                        method_for_nc_impl<ITYPE, IRANK - 1, IFNAME, IVNAME, ISYM, FIRANK, OTYPE, ORANK - 1, OFNAME, OVNAME, FORANK, OMP_LEVELS - 1, DEPTH + 1>(iarray_in(i), i)(func, oarray(i));
                    }
                } else {
                    if constexpr (ORANK == FORANK) {
                        method_for_nc_impl<ITYPE, IRANK - 1, IFNAME, IVNAME, ISYM, FIRANK, OTYPE, ORANK,     OFNAME, OVNAME, FORANK, OMP_LEVELS - 1, DEPTH + 1>(iarray_in(i))(func, oarray);
                    } else {
                        method_for_nc_impl<ITYPE, IRANK - 1, IFNAME, IVNAME, ISYM, FIRANK, OTYPE, ORANK - 1, OFNAME, OVNAME, FORANK, OMP_LEVELS - 1, DEPTH + 1>(iarray_in(i))(func, oarray(i));
                    }
                }
            };

            if constexpr (OMP_LEVELS > 0) {
                size_t i = imin_in;
                #pragma omp parallel for private(i)
                for (i = imin_in; i < iarray_in.current_extent(); i++) {
                    loop(i);
                }
            } else { // if constexpr (OMP_LEVELS == 0)
                for (size_t i = imin_in; i < iarray_in.current_extent(); i++) {
                    loop(i);
                }
            }

        };


        if constexpr (DEPTH == 0) {

            typedef const void (OWRFTYPE)(nested_netcdf_array_t<ITYPE, IRANK, IFNAME, IVNAME, ISYM>, nested_netcdf_array_t<OTYPE, ORANK, OFNAME, OVNAME>);
            return [iarray_in, imin_in, mloop](FTYPE func, nested_netcdf_array_t<OTYPE, ORANK, OFNAME, OVNAME> oarray, OWRFTYPE owrfunc) {

                for (int i = 0; i < ORANK - FORANK; i++) {
                    oarray.set_extent(i, iarray_in.extent(i));
                }

                oarray.write_init(&iarray_in, FORANK); // copy all the identical metadata
                owrfunc(iarray_in, oarray); // provide user interface for non-identical metadata, with access to both arrays
                oarray.check_dim_completeness();

                nc_redef(oarray.file_id());
                nc_def_var(oarray.file_id(), oarray.variable_name, oarray.var_type(), ORANK, oarray.dim_ids(), oarray.var_id()); // generalize type
                nc_enddef(oarray.file_id());

                mloop(func, oarray);
            };

        } else {

            return mloop;

        }

    }

}
*/

/** The method_for loop is a grammatical orientation of the nested_for loop that allows you to tie an
 *  iteration pattern to an input array, and later pass it an output array and  a function to evaluate
 *  with the data. This is useful for evaluating several different functions (with the same input/output
 *  types) over an input array of arbitrary shape and dimensionality.
 *
 *  method_for loops support symmetry optimization. The best way to structure data for symmetry
 *  optimization is to ensure that all symmetric dimensions in a symmetry group are sequential. Mixed
 *  grouping will break this optimization. A 1-D array of arbitrary integers; equal values
 *  imply symmetry between different dimensions.
 *
 * @tparam NITYPE       The input array type.
 * @tparam NOTYPE       The output array type.
 * @tparam CLTYPE       The closure type.
 * @tparam OMP_LEVELS   The number of dimensions to parallelize with OpenMP. This will apply to the first
 *                      OMP_LEVELS dimensions.
 *
 * @return          A lambda function that iterates through the input array's top-level dimension,
 *                  and spawns new method_for objects to continue traversal when called. At the lowest
 *                  level, it stores a lambda function that simply calls the function on the data. method_for
 *                  loops have a recursive function type that nests with input array rank.
 */
template<typename NITYPE, typename NOTYPE, typename CLTYPE, const int OMP_LEVELS = 0, const bool ACC_ON = false>
constexpr auto method_for(NITYPE iarray_in){
    return method_for_impl<typename NITYPE::value_type, NITYPE::rank, NITYPE::symmetry,              CLTYPE::input_rank,
                           typename NOTYPE::value_type, NOTYPE::rank,                                CLTYPE::output_rank,
                           OMP_LEVELS, false, ACC_ON>(iarray_in);
}
/*
template<typename NITYPE, typename NOTYPE, typename CLTYPE, const int OMP_LEVELS = 0, const bool ACC_ON = false>
constexpr auto method_for_nc(NITYPE iarray_in){
    return method_for_nc_impl<typename NITYPE::value_type, NITYPE::rank, NITYPE::file_name, NITYPE::variable_name, NITYPE::symmetry, CLTYPE::input_rank,
                              typename NOTYPE::value_type, NOTYPE::rank, NOTYPE::file_name, NOTYPE::variable_name,,
                              OMP_LEVELS, false, ACC_ON>(iarray_in);
}
*/
#endif
